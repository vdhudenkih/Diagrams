напиши программу на яп c#:
на вход подаётся массив строк вида:
<lemma id="40803" rev="404710"><l t="велотренажёр"><g v="NOUN"/><g v="inan"/><g v="masc"/></l><f t="велотренажёр"><g v="sing"/><g v="nomn"/></f><f t="велотренажёра"><g v="sing"/><g v="gent"/></f><f t="велотренажёру"><g v="sing"/><g v="datv"/></f><f t="велотренажёр"><g v="sing"/><g v="accs"/></f><f t="велотренажёром"><g v="sing"/><g v="ablt"/></f><f t="велотренажёре"><g v="sing"/><g v="loct"/></f><f t="велотренажёры"><g v="plur"/><g v="nomn"/></f><f t="велотренажёров"><g v="plur"/><g v="gent"/></f><f t="велотренажёрам"><g v="plur"/><g v="datv"/></f><f t="велотренажёры"><g v="plur"/><g v="accs"/></f><f t="велотренажёрами"><g v="plur"/><g v="ablt"/></f><f t="велотренажёрах"><g v="plur"/><g v="loct"/></f></lemma>
<lemma id="40812" rev="40812"><l t="вельветовый"><g v="ADJF"/></l><f t="вельветовый"><g v="masc"/><g v="sing"/><g v="nomn"/></f><f t="вельветового"><g v="masc"/><g v="sing"/><g v="gent"/></f><f t="вельветовому"><g v="masc"/><g v="sing"/><g v="datv"/></f><f t="вельветового"><g v="anim"/><g v="masc"/><g v="sing"/><g v="accs"/></f><f t="вельветовый"><g v="inan"/><g v="masc"/><g v="sing"/><g v="accs"/></f><f t="вельветовым"><g v="masc"/><g v="sing"/><g v="ablt"/></f><f t="вельветовом"><g v="masc"/><g v="sing"/><g v="loct"/></f><f t="вельветовая"><g v="femn"/><g v="sing"/><g v="nomn"/></f><f t="вельветовой"><g v="femn"/><g v="sing"/><g v="gent"/></f><f t="вельветовой"><g v="femn"/><g v="sing"/><g v="datv"/></f><f t="вельветовую"><g v="femn"/><g v="sing"/><g v="accs"/></f><f t="вельветовой"><g v="femn"/><g v="sing"/><g v="ablt"/></f><f t="вельветовою"><g v="femn"/><g v="sing"/><g v="ablt"/><g v="V-oy"/></f><f t="вельветовой"><g v="femn"/><g v="sing"/><g v="loct"/></f><f t="вельветовое"><g v="neut"/><g v="sing"/><g v="nomn"/></f><f t="вельветового"><g v="neut"/><g v="sing"/><g v="gent"/></f><f t="вельветовому"><g v="neut"/><g v="sing"/><g v="datv"/></f><f t="вельветовое"><g v="neut"/><g v="sing"/><g v="accs"/></f><f t="вельветовым"><g v="neut"/><g v="sing"/><g v="ablt"/></f><f t="вельветовом"><g v="neut"/><g v="sing"/><g v="loct"/></f><f t="вельветовые"><g v="plur"/><g v="nomn"/></f><f t="вельветовых"><g v="plur"/><g v="gent"/></f><f t="вельветовым"><g v="plur"/><g v="datv"/></f><f t="вельветовых"><g v="anim"/><g v="plur"/><g v="accs"/></f><f t="вельветовые"><g v="inan"/><g v="plur"/><g v="accs"/></f><f t="вельветовыми"><g v="plur"/><g v="ablt"/></f><f t="вельветовых"><g v="plur"/><g v="loct"/></f></lemma>
и слово вида "велотренажер"
программа должна вернуть массив, где содержится это слово, причем игнорировать различия в е и ё
для данного примера результат будет:
<lemma id="40803" rev="404710"><l t="велотренажёр"><g v="NOUN"/><g v="inan"/><g v="masc"/></l><f t="велотренажёр"><g v="sing"/><g v="nomn"/></f><f t="велотренажёра"><g v="sing"/><g v="gent"/></f><f t="велотренажёру"><g v="sing"/><g v="datv"/></f><f t="велотренажёр"><g v="sing"/><g v="accs"/></f><f t="велотренажёром"><g v="sing"/><g v="ablt"/></f><f t="велотренажёре"><g v="sing"/><g v="loct"/></f><f t="велотренажёры"><g v="plur"/><g v="nomn"/></f><f t="велотренажёров"><g v="plur"/><g v="gent"/></f><f t="велотренажёрам"><g v="plur"/><g v="datv"/></f><f t="велотренажёры"><g v="plur"/><g v="accs"/></f><f t="велотренажёрами"><g v="plur"/><g v="ablt"/></f><f t="велотренажёрах"><g v="plur"/><g v="loct"/></f></lemma>



string word = "велотренажер";
string[] strSearch = fileContent
    .Where(s => s.IndexOf(word, StringComparison.CurrentCultureIgnoreCase) >= 0)
    .ToArray();


почему при word="велотренажер"
программа
string[] strSearch = fileContent.Where(s => s.Contains("\"" + word + "\"", StringComparison.CurrentCultureIgnoreCase)).ToArray();
не находит слово в подстроке строки массива, хотя оно там есть



напиши функцию на ЯП C# по следующему условию:
на вход подаётся текстовый файл, путь которого "input.txt"
функция считывает его построчно, после чего обрезает все символы, следующее после символа "\"
на выход программа даёт массив строк



using System;
using System.IO;

class Program
{
    static string[] ProcessFile(string filePath)
    {
        var lines = File.ReadAllLines(filePath);
        for (int i = 0; i < lines.Length; i++)
        {
            int index = lines[i].IndexOf('\\');
            if (index >= 0)
            {
                lines[i] = lines[i].Substring(0, index);
            }
        }
        return lines;
    }

    static void Main()
    {
        string[] result = ProcessFile("input.txt");
        foreach (var line in result)
        {
            Console.WriteLine(line);
        }
    }
}




string[] testData = ProcessFile("input.txt");
        float countNotDictionary = 0;
        float countWords = 0;
        for (int test = 0; test < testData.Length; test++)
        {
            string inputString = testData[test];
            inputString = inputString.ToLower();
            inputString = inputString.Replace("-", " ");
            inputString = inputString.Replace("(", " ");
            inputString = inputString.Replace(")", " ");
            inputString = inputString.Replace("|", "");
            string[] inputMaterials = inputString.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries); //Разделяем строку в массив по пробелам
            string[] lemmas;
            List<Word> words = new List<Word>();
            for (int i = 0; i < inputMaterials.Length; i++)
            {
                lemmas = SearchInDictionary(inputMaterials[i]).Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                for (int j = 0; j < lemmas.Length; j++)
                {
                    string[] list = lemmas[j].Split(new char[] { '-' }, StringSplitOptions.RemoveEmptyEntries);
                    //Указанные ниже буквы нужно исключить ввиду засорения вывода программы, из-за наличия огромного количества их одинаковых форм. Такие символы обычно встечаются в формате сокращений с цифрами. Например: 2-ух, 2-х, 8-ми, 9-ти
                    if (list.Length >= 6 && list[1] != "х" && list[1] != "ми" && list[1] != "ти" && list[1] != "ух")
                    {
                        words.Add(new Word(list[0], i, list[1], list[2], list[3], list[4], list[5], list[6]));
                        countWords++;
                    }
                    else
                    {
                        //Если не нужна обработка ошибок
                        words.Add(new Word("999999" + i, i, inputMaterials[i], "0000", "0000", "0000", "0000", "0000"));
                        countNotDictionary++;
                        countWords++;
                        break;
                    }
                }
           }
        }
        Console.WriteLine(countNotDictionary/countWords);
