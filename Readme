некорректный вывод:
на вход было дано
wordOrder: 1, wordText: гаечный, wordId: 65785, partOfSpeech: ADJF, wordKind: masc, singPlur: plur, wordCase: gent
ожидалось:
wordOrder: 1, wordText: гаечных, wordId: 65785, partOfSpeech: ADJF, wordKind: masc, singPlur: plur, wordCase: gent
получено:
wordOrder: 1, wordText: гаечный, wordId: 65785, partOfSpeech: ADJF, wordKind: masc, singPlur: plur, wordCase: gent
строка файла словаря:
<lemma id="65785" rev="65785"><l t="гаечный"><g v="ADJF"/><g v="Qual"/></l><f t="гаечный"><g v="masc"/><g v="sing"/><g v="nomn"/></f><f t="гаечного"><g v="masc"/><g v="sing"/><g v="gent"/></f><f t="гаечному"><g v="masc"/><g v="sing"/><g v="datv"/></f><f t="гаечного"><g v="anim"/><g v="masc"/><g v="sing"/><g v="accs"/></f><f t="гаечный"><g v="inan"/><g v="masc"/><g v="sing"/><g v="accs"/></f><f t="гаечным"><g v="masc"/><g v="sing"/><g v="ablt"/></f><f t="гаечном"><g v="masc"/><g v="sing"/><g v="loct"/></f><f t="гаечная"><g v="femn"/><g v="sing"/><g v="nomn"/></f><f t="гаечной"><g v="femn"/><g v="sing"/><g v="gent"/></f><f t="гаечной"><g v="femn"/><g v="sing"/><g v="datv"/></f><f t="гаечную"><g v="femn"/><g v="sing"/><g v="accs"/></f><f t="гаечной"><g v="femn"/><g v="sing"/><g v="ablt"/></f><f t="гаечною"><g v="femn"/><g v="sing"/><g v="ablt"/><g v="V-oy"/></f><f t="гаечной"><g v="femn"/><g v="sing"/><g v="loct"/></f><f t="гаечное"><g v="neut"/><g v="sing"/><g v="nomn"/></f><f t="гаечного"><g v="neut"/><g v="sing"/><g v="gent"/></f><f t="гаечному"><g v="neut"/><g v="sing"/><g v="datv"/></f><f t="гаечное"><g v="neut"/><g v="sing"/><g v="accs"/></f><f t="гаечным"><g v="neut"/><g v="sing"/><g v="ablt"/></f><f t="гаечном"><g v="neut"/><g v="sing"/><g v="loct"/></f><f t="гаечные"><g v="plur"/><g v="nomn"/></f><f t="гаечных"><g v="plur"/><g v="gent"/></f><f t="гаечным"><g v="plur"/><g v="datv"/></f><f t="гаечных"><g v="anim"/><g v="plur"/><g v="accs"/></f><f t="гаечные"><g v="inan"/><g v="plur"/><g v="accs"/></f><f t="гаечными"><g v="plur"/><g v="ablt"/></f><f t="гаечных"><g v="plur"/><g v="loct"/></f></lemma>





using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Linq;

public class Word
{
    public int wordOrder;
    public string wordText;
    public string wordId;
    public string partOfSpeech;
    public string wordKind;
    public string singPlur;
    public string wordCase;
}

public class ReplacementByModifyers
{
    private static readonly Dictionary<int, string> LemmaFiles = new Dictionary<int, string>
    {
        { 25000, "lemmas1.txt" },
        { 50000, "lemmas2.txt" },
        { 75000, "lemmas3.txt" },
        { 100500, "lemmas4.txt" },
        { 125000, "lemmas5.txt" },
        { 150000, "lemmas6.txt" },
        { 175000, "lemmas7.txt" },
        { 195600, "lemmas8.txt" },
        { 219999, "lemmas9.txt" },
        { 244000, "lemmas10.txt" },
        { 268000, "lemmas11.txt" },
        { 291000, "lemmas12.txt" },
        { 315500, "lemmas13.txt" },
        { 340000, "lemmas14.txt" },
        { 362000, "lemmas15.txt" },
        { 372000, "lemmas16.txt" },
        { 417260, "lemmas17.txt" }
    };

    public static List<Word> ReplaceWords(List<Word> words)
    {
        foreach (var word in words)
        {
            if (!int.TryParse(word.wordId, out int wordId))
                continue;

            string lemmaFile = GetLemmaFile(wordId);
            if (string.IsNullOrEmpty(lemmaFile))
                continue;

            string newWordText = FindWordForm(lemmaFile, word);
            if (!string.IsNullOrEmpty(newWordText))
            {
                word.wordText = newWordText;
            }
        }

        return words;
    }

    private static string GetLemmaFile(int wordId)
    {
        foreach (var pair in LemmaFiles.OrderBy(x => x.Key))
        {
            if (wordId <= pair.Key)
                return pair.Value;
        }
        return null;
    }

    private static string FindWordForm(string lemmaFile, Word word)
    {
        try
        {
            string xmlContent = File.ReadAllText(lemmaFile);
            XDocument doc = XDocument.Parse($"<root>{xmlContent}</root>");

            var lemma = doc.Descendants("lemma")
                .FirstOrDefault(l => l.Attribute("id")?.Value == word.wordId);

            if (lemma == null)
                return null;

            var form = lemma.Elements("f")
                .FirstOrDefault(f =>
                {
                    var grams = f.Elements("g").Select(g => g.Attribute("v")?.Value).ToList();
                    bool matchesSingPlur = grams.Contains(word.singPlur);
                    bool matchesCase = grams.Contains(word.wordCase);
                    bool matchesKind = word.partOfSpeech == "ADJF" ? grams.Contains(word.wordKind) : true;
                    return matchesSingPlur && matchesCase && matchesKind;
                });

            return form?.Attribute("t")?.Value;
        }
        catch
        {
            return null;
        }
    }
}


Напишу функцию с названием ReplacementByModifyers на ЯП C#:
на вход подаётся List<Word> words
программа считывает все объекты класса Word с параметрами:
public int wordOrder;
public string wordText;
public string wordId;
public string partOfSpeech;
public string wordKind;
public string singPlur;
public string wordCase;
типичным объектом будет, например: wordOrder: 
wordOrder: 1, wordText: война, wordId: 49721, partOfSpeech: NOUN, wordKind: femn, singPlur: sing, wordCase: gent
wordOrder: 1, wordText: красивый, wordId: 141641, partOfSpeech: ADJF, wordKind: femn, singPlur: sing, wordCase: nomn
Это объект, в поле которого указана лемма (в примере "война"), НО признаки (wordKind: femn, singPlur: sing, wordCase: gent) это признаки, по которым должна быть найдена форма слова в файле словаря.
Всего существует 17 словарей формата от "lemmas1.txt" до "lemmas17.txt"
Чтобы выбрать нужный словарь для поиска используется wordId.
в "lemmas1.txt" содержатся wordId= c 1 до 25000
в "lemmas2.txt" содержатся wordId= c 25001 до 50000
в "lemmas3.txt" содержатся wordId= c 50001 до 75000
в "lemmas4.txt" содержатся wordId= c 75001 до 100500
в "lemmas5.txt" содержатся wordId= c 100501 до 125000
в "lemmas6.txt" содержатся wordId= c 125001 до 150000
в "lemmas7.txt" содержатся wordId= c 150001 до 175000
в "lemmas8.txt" содержатся wordId= c 175001 до 195600
в "lemmas9.txt" содержатся wordId= c 195601 до 219999
в "lemmas10.txt" содержатся wordId= c 220000 до 244000
в "lemmas11.txt" содержатся wordId= c 244001 до 268000
в "lemmas12.txt" содержатся wordId= c 268001 до 291000
в "lemmas13.txt" содержатся wordId= c 291001 до 315500
в "lemmas14.txt" содержатся wordId= c 315501 до 340000
в "lemmas15.txt" содержатся wordId= c 340001 до 362000
в "lemmas16.txt" содержатся wordId= c 362001 до 372000
в "lemmas17.txt" содержатся wordId= c 372001 до 417260
В словаре организация данных выполнена следующим образом:
для примера "война":
<lemma id="49721" rev="49721"><l t="война"><g v="NOUN"/><g v="inan"/><g v="femn"/></l><f t="война"><g v="sing"/><g v="nomn"/></f><f t="войны"><g v="sing"/><g v="gent"/></f><f t="войне"><g v="sing"/><g v="datv"/></f><f t="войну"><g v="sing"/><g v="accs"/></f><f t="войной"><g v="sing"/><g v="ablt"/></f><f t="войною"><g v="sing"/><g v="ablt"/><g v="V-oy"/></f><f t="войне"><g v="sing"/><g v="loct"/></f><f t="войны"><g v="plur"/><g v="nomn"/></f><f t="войн"><g v="plur"/><g v="gent"/></f><f t="войнам"><g v="plur"/><g v="datv"/></f><f t="войны"><g v="plur"/><g v="accs"/></f><f t="войнами"><g v="plur"/><g v="ablt"/></f><f t="войнах"><g v="plur"/><g v="loct"/></f></lemma>
для примера "красивый":
<lemma id="141641" rev="141641"><l t="красивый"><g v="ADJF"/><g v="Qual"/></l><f t="красивый"><g v="masc"/><g v="sing"/><g v="nomn"/></f><f t="красивого"><g v="masc"/><g v="sing"/><g v="gent"/></f><f t="красивому"><g v="masc"/><g v="sing"/><g v="datv"/></f><f t="красивого"><g v="anim"/><g v="masc"/><g v="sing"/><g v="accs"/></f><f t="красивый"><g v="inan"/><g v="masc"/><g v="sing"/><g v="accs"/></f><f t="красивым"><g v="masc"/><g v="sing"/><g v="ablt"/></f><f t="красивом"><g v="masc"/><g v="sing"/><g v="loct"/></f><f t="красивая"><g v="femn"/><g v="sing"/><g v="nomn"/></f><f t="красивой"><g v="femn"/><g v="sing"/><g v="gent"/></f><f t="красивой"><g v="femn"/><g v="sing"/><g v="datv"/></f><f t="красивую"><g v="femn"/><g v="sing"/><g v="accs"/></f><f t="красивой"><g v="femn"/><g v="sing"/><g v="ablt"/></f><f t="красивою"><g v="femn"/><g v="sing"/><g v="ablt"/><g v="V-oy"/></f><f t="красивой"><g v="femn"/><g v="sing"/><g v="loct"/></f><f t="красивое"><g v="neut"/><g v="sing"/><g v="nomn"/></f><f t="красивого"><g v="neut"/><g v="sing"/><g v="gent"/></f><f t="красивому"><g v="neut"/><g v="sing"/><g v="datv"/></f><f t="красивое"><g v="neut"/><g v="sing"/><g v="accs"/></f><f t="красивым"><g v="neut"/><g v="sing"/><g v="ablt"/></f><f t="красивом"><g v="neut"/><g v="sing"/><g v="loct"/></f><f t="красивые"><g v="plur"/><g v="nomn"/></f><f t="красивых"><g v="plur"/><g v="gent"/></f><f t="красивым"><g v="plur"/><g v="datv"/></f><f t="красивых"><g v="anim"/><g v="plur"/><g v="accs"/></f><f t="красивые"><g v="inan"/><g v="plur"/><g v="accs"/></f><f t="красивыми"><g v="plur"/><g v="ablt"/></f><f t="красивых"><g v="plur"/><g v="loct"/></f></lemma>
Для данных примеров должен быть следующий результат:
для wordOrder: 1, wordText: война, wordId: 49721, partOfSpeech: NOUN, wordKind: femn, singPlur: sing, wordCase: gent
результат: wordOrder: 1, wordText: войны, wordId: 49721, partOfSpeech: NOUN, wordKind: femn, singPlur: sing, wordCase: gent
для wordOrder: 1, wordText: красивый, wordId: 141641, partOfSpeech: ADJF, wordKind: femn, singPlur: sing, wordCase: nomn
результат: 1, wordText: красивая, wordId: 141641, partOfSpeech: ADJF, wordKind: femn, singPlur: sing, wordCase: nomn






напиши функцию с названием ModifyWords на ЯП c# по следующему условию:
на вход подаётся List<Word> words
программа считывает все объекты класса Word с параметрами:
public int wordOrder;
public string wordText;
public string wordId;
public string partOfSpeech;
public string wordKind;
public string singPlur;
public string wordCase;
типичным объектом будет, например "0, кошка, 1000, NOUN, femn, nomn"
Тебе нужно изменить параметры объектов по следующей логике:
Если параметр одного объекта partOfSpeech=NOUN и нет объекта где (wordText="для" или "от" или "из" или "к" или "с" или "в" или "на" или "под" или "через")
то:{
    если нет других объектов с параметром partOfSpeech=NOUN 
    то:{
        изменить (параметры wordKind и wordCase на равные аналогичным у объекта с параметром NOUN) у всех объектов, где параметр partOfSpeech=ADJF 
        }
    иначе:
        {
        Если нет объектов с параметром ADJF:
        то:
            {
                если не (объект с параметром wordOrder==0 имеет параметр wordText= "набор" или "комплект" или "каталог" или "блок")
                то:{
                    изменить параметры wordCase всех объектов, кроме объекта с параметром wordOrder==0, на wordCase="gent"
                    }
                иначе:
                    {
                    изменить параметры (wordKind и wordCase и singPlur всех объектов, кроме объекта с параметром wordOrder==0), на (wordKind="masc" и wordCase="gent" и singPlur="plur")
                    }
            }
        Иначе:
        {
            если (объект с параметром wordOrder==0 имеет параметр wordText= "набор" или "комплект" или "каталог" или "блок")
            то:
            {
                изменить параметры (wordKind и wordCase и singPlur всех объектов, кроме объекта с параметром wordOrder==0), на  wordKind="masc" и wordCase="gent" и singPlur="plur"
            }
            иначе:
            {
                изменить параметры (wordKind и wordCase и singPlur всех объектов, кроме объекта с параметром wordOrder==0), на  равные объекту с параметром wordOrder==0
                изменить параметр (wordCase всех объектов, кроме объекта с параметром wordOrder==0), на wordCase="gent"
            }
        }
        }
}
иначе:
{
    для всех объектов ДО обьекта с параметром (wordText="для" или "от" или "из" или "к" или "с" или "в" или "на" или "под" или "через") выполнить:
    {
    если нет других объектов с параметром partOfSpeech=NOUN 
        то:{
            изменить (параметры wordKind и wordCase на равные аналогичным у объекта с параметром NOUN) у всех объектов, где параметр partOfSpeech=ADJF 
            }
        иначе:
            {
            Если нет объектов с параметром ADJF:
            то:
                {
                    если не (объект с параметром wordOrder==0 имеет параметр wordText= "набор" или "комплект" или "каталог" или "блок")
                    то:{
                        изменить параметры wordCase всех объектов, кроме объекта с параметром wordOrder==0, на wordCase="gent"
                        }
                    иначе:
                        {
                        изменить параметры (wordKind и wordCase и singPlur всех объектов, кроме объекта с параметром wordOrder==0), на (wordKind="masc" и wordCase="gent" и singPlur="plur")
                        }
                }
            Иначе:
            {
                если (объект с параметром wordOrder==0 имеет параметр wordText= "набор" или "комплект" или "каталог" или "блок")
                то:
                {
                    изменить параметры (wordKind и wordCase и singPlur всех объектов, кроме объекта с параметром wordOrder==0), на  wordKind="masc" и wordCase="gent" и singPlur="plur"
                }
                иначе:
                {
                    изменить параметры (wordKind и wordCase и singPlur всех объектов, кроме объекта с параметром wordOrder==0), на  равные объекту с параметром wordOrder==0
                    изменить параметр (wordCase всех объектов, кроме объекта с параметром wordOrder==0), на wordCase="gent"
                }
            }
        }
    }
    для всех объектов ПОСЛЕ обьекта с параметром (wordText="для" или "от" или "из" или "к" или "с" или "в" или "на" или "под" или "через") выполнить:
    {
        Если найден объект с параметром (wordText="для" или "от" или "из")
        {
            Изменить параметры (wordCase на wordCase="gent") всех объектов, следующих после объекта с параметром (wordText="для" или "от" или "из")
        }
        Иначе если найден объект с параметром (wordText="на" или "под" или "через")
        {
            Изменить параметры (wordCase на wordCase="accs") всех объектов, следующих после объекта с параметром (wordText="на" или "под" или "через")
        }
        Иначе если найден объект с параметром (wordText="в")
        {
            Изменить параметры (wordCase на wordCase="loct") всех объектов, следующих после объекта с параметром (wordText="в")
        }
        Иначе если найден объект с параметром (wordText="с")
        {
            Изменить параметры (wordCase на wordCase="ablt") всех объектов, следующих после объекта с параметром (wordText="с")
        }
        Иначе если найден объект с параметром (wordText="к")
        {
            Изменить параметры (wordCase на wordCase="datv") всех объектов, следующих после объекта с параметром (wordText="к")
        }
    }
}

