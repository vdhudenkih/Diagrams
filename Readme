using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

public class LemmaParser
{
    public static List<string> ParseLemma(string inputWord, string lemmaXml)
    {
        var result = new List<string>();

        // Извлекаем все формы слова из XML
        var forms = Regex.Matches(lemmaXml, @"<f t=""([^""]+)"">(.*?)</f>");
        
        foreach (Match form in forms)
        {
            string formWord = form.Groups[1].Value;
            if (formWord == inputWord)
            {
                // Извлекаем теги для данной формы
                var tags = Regex.Matches(form.Groups[2].Value, @"<g v=""([^""]+)""");
                var tagList = tags.Cast<Match>().Select(t => t.Groups[1].Value).ToList();
                
                // Извлекаем основной тег части речи из lemma
                string posTag = Regex.Match(lemmaXml, @"<l t=""[^""]+"">(.*?)</l>").Groups[1].Value;
                posTag = Regex.Matches(posTag, @"<g v=""([^""]+)""").Cast<Match>()
                    .Select(t => t.Groups[1].Value)
                    .FirstOrDefault(t => t == "NOUN" || t == "ADJF") ?? "0000";

                // Формируем базовую строку
                string baseResult = $"{inputWord}-{posTag}";

                // Добавляем грамматические теги
                string caseTag = tagList.FirstOrDefault(t => new[] { "nomn", "gent", "datv", "accs", "ablt", "loct" }.Contains(t)) ?? "0000";
                baseResult += $"-{caseTag}";

                // Добавляем anim/inan
                string animTag = tagList.Contains("anim") ? "anim" : tagList.Contains("inan") ? "inan" : "0000";
                baseResult += $"-{animTag}";

                // Добавляем род
                string genderTag = tagList.FirstOrDefault(t => new[] { "masc", "femn", "neut" }.Contains(t)) ?? "0000";
                baseResult += $"-{genderTag}";

                // Добавляем число
                string numberTag = tagList.FirstOrDefault(t => new[] { "sing", "plur" }.Contains(t)) ?? "0000";
                baseResult += $"-{numberTag}";

                result.Add(baseResult);
            }
        }

        return result;
    }
}






using System;
using System.Linq;
using System.Xml.Linq;

public class WordParser
{
    public static string ParseWord(string word, string lemmaXml)
    {
        try
        {
            // Parse XML
            XElement lemma = XElement.Parse(lemmaXml);
            
            // Find the form matching the input word
            var form = lemma.Elements("f")
                .FirstOrDefault(f => f.Attribute("t")?.Value == word);
            
            if (form == null)
                return "Word not found in lemma";

            // Get lemma attributes
            var lemmaAttrs = lemma.Element("l")?.Elements("g")
                .Select(g => g.Attribute("v")?.Value)
                .Where(v => v != null)
                .ToList() ?? new List<string>();

            // Get form attributes
            var formAttrs = form.Elements("g")
                .Select(g => g.Attribute("v")?.Value)
                .Where(v => v != null)
                .ToList() ?? new List<string>();

            // Combine attributes
            var allAttrs = lemmaAttrs.Concat(formAttrs).ToList();

            // Ensure output has exactly 6 components
            // Format: word-POS-case-animacy-gender-number
            string pos = allAttrs.FirstOrDefault(a => new[] { "NOUN", "ADJF" }.Contains(a)) ?? "0000";
            string caseAttr = allAttrs.FirstOrDefault(a => new[] { "nomn", "gent", "datv", "accs", "ablt", "loct" }.Contains(a)) ?? "0000";
            string animacy = allAttrs.Contains("anim") ? "anim" : (allAttrs.Contains("inan") ? "inan" : "0000");
            string gender = allAttrs.FirstOrDefault(a => new[] { "masc", "femn", "neut" }.Contains(a)) ?? "0000";
            string number = allAttrs.FirstOrDefault(a => new[] { "sing", "plur" }.Contains(a)) ?? "0000";

            return $"{word}-{pos}-{caseAttr}-{animacy}-{gender}-{number}";
        }
        catch (Exception ex)
        {
            return $"Error processing lemma: {ex.Message}";
        }
    }
}





напиши функцию на ЯП c# по следующему условию:
на вход подается массив типа string и подаются объекты класса Word вида List<Word> words = new List<Word>() с полями 
public int wordOrder;
public string wordText;
public string partOfSpeech;
public string wordCase;
public string animation;
public string wordKind;
public string singPlur;
программа печатает в файл "output.txt" следующее:
при входе 
wordOrder: 0, wordText: компрессионный, partOfSpeech: ADJF, wordCase: gent, animation: 0000 wordKind: masc, singPlur: sing
wordOrder: 1, wordText: мешок, partOfSpeech: NOUN, wordCase: gent, animation: anim wordKind: masc, singPlur: sing
wordOrder: 1, wordText: мешок, partOfSpeech: NOUN, wordCase: gent, animation: inan wordKind: masc, singPlur: sing
на выход идёт:

напиши функцию на ЯП c# по следующему условию:
на вход подаётся строка вида "мешки", строка вида <lemma id="159552" rev="159552"><l t="мешок"><g v="NOUN"/><g v="anim"/><g v="masc"/></l><f t="мешок"><g v="sing"/><g v="nomn"/></f><f t="мешка"><g v="sing"/><g v="gent"/></f><f t="мешку"><g v="sing"/><g v="datv"/></f><f t="мешка"><g v="sing"/><g v="accs"/></f><f t="мешком"><g v="sing"/><g v="ablt"/></f><f t="мешке"><g v="sing"/><g v="loct"/></f><f t="мешки"><g v="plur"/><g v="nomn"/></f><f t="мешков"><g v="plur"/><g v="gent"/></f><f t="мешкам"><g v="plur"/><g v="datv"/></f><f t="мешков"><g v="plur"/><g v="accs"/></f><f t="мешками"><g v="plur"/><g v="ablt"/></f><f t="мешках"><g v="plur"/><g v="loct"/></f></lemma>
на выходе должно быть получено: 
мешки-NOUN-nomn-anim-masc-plur
на вход подаётся "компрессионного" <lemma id="137363" rev="137363"><l t="компрессионный"><g v="ADJF"/></l><f t="компрессионный"><g v="masc"/><g v="sing"/><g v="nomn"/></f><f t="компрессионного"><g v="masc"/><g v="sing"/><g v="gent"/></f><f t="компрессионному"><g v="masc"/><g v="sing"/><g v="datv"/></f><f t="компрессионного"><g v="anim"/><g v="masc"/><g v="sing"/><g v="accs"/></f><f t="компрессионный"><g v="inan"/><g v="masc"/><g v="sing"/><g v="accs"/></f><f t="компрессионным"><g v="masc"/><g v="sing"/><g v="ablt"/></f><f t="компрессионном"><g v="masc"/><g v="sing"/><g v="loct"/></f><f t="компрессионная"><g v="femn"/><g v="sing"/><g v="nomn"/></f><f t="компрессионной"><g v="femn"/><g v="sing"/><g v="gent"/></f><f t="компрессионной"><g v="femn"/><g v="sing"/><g v="datv"/></f><f t="компрессионную"><g v="femn"/><g v="sing"/><g v="accs"/></f><f t="компрессионной"><g v="femn"/><g v="sing"/><g v="ablt"/></f><f t="компрессионною"><g v="femn"/><g v="sing"/><g v="ablt"/><g v="V-oy"/></f><f t="компрессионной"><g v="femn"/><g v="sing"/><g v="loct"/></f><f t="компрессионное"><g v="neut"/><g v="sing"/><g v="nomn"/></f><f t="компрессионного"><g v="neut"/><g v="sing"/><g v="gent"/></f><f t="компрессионному"><g v="neut"/><g v="sing"/><g v="datv"/></f><f t="компрессионное"><g v="neut"/><g v="sing"/><g v="accs"/></f><f t="компрессионным"><g v="neut"/><g v="sing"/><g v="ablt"/></f><f t="компрессионном"><g v="neut"/><g v="sing"/><g v="loct"/></f><f t="компрессионные"><g v="plur"/><g v="nomn"/></f><f t="компрессионных"><g v="plur"/><g v="gent"/></f><f t="компрессионным"><g v="plur"/><g v="datv"/></f><f t="компрессионных"><g v="anim"/><g v="plur"/><g v="accs"/></f><f t="компрессионные"><g v="inan"/><g v="plur"/><g v="accs"/></f><f t="компрессионными"><g v="plur"/><g v="ablt"/></f><f t="компрессионных"><g v="plur"/><g v="loct"/></f></lemma>
на выход: компрессионного-ADJF-gent-0000-masc-sing
компрессионного-ADJF-gent-0000-masc-sing
компрессионного-ADJF-accs-inan-masc-sing
компрессионного-ADJF-gent-0000-neut-sing
